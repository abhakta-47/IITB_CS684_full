(*********************************************************************************
Inputs:
    Values from 5 White Line Sensors.
    Each Sensor value ranges between: 0 to 1023.
    On white surface, sensor values are low and for black surface, sensor values are high.
Outputs:
    3 for controlling the motion of the Robot (1 for Direction and 2 for Motor's velocities).
    From the final heptagon node, 3 outputs are required: 2 velocity values (of left and right motors) and direction.
    Directions list:
        Direction	Representation
        Stop	        0
        Forward	        1
        Left	        2
        Right	        3
        Backward	    4
    Motor velocity ranges between 0 to 100. It should not be negative or greater than 100.
- Consider a black line on white surface.
- Use PID controller for line following.
- You are free to make assumptions regarding
    readings of white line sensors at different instances,
    distance covered by robot for different motions in single step etc.
**********************************************************************************)

(**********************************
CONFIGURATION CONSTANTS START
***********************************)
(* Sensor related *)
const sensor_min: int = 0
const sensor_max: int = 1023
const sensor_weights: int^5 = [-1000, -100, 0, 100, 1000]
(* PID gains and ranges *)
(* Gains should be determined through field trials *)
(* for float approximation kscale is used effective k* would be k*/kscale *)
const kscale: int = 1000  -- Using integer division for scaling down
const kp: int = 50 -- effective kp/kscale
const kd: int = 5 -- effective kd/kscale
const ki: int = 0 -- effective ki/kscale
const max_i: int = 200000000  -- to prevent integral overflow
(* accelaration param *)
const acc_thresh: int = 10
const base_sraight_speed: int = 40 -- 50
const base_turn_speed: int = 40 -- 40
(********************************
CONFIGURATION CONSTANTS END
*********************************)

(* PID error computation *)
node calPidError(value: int) returns (pid_error: int)
var p, i, d: int;
let
     p = value;
     (* Integral term with overflow prevention *)
     i = if ((0->pre(i) + value) <= max_i) then (0->pre(i) + value) else max_i;
     d = value - 0->pre(value);
     pid_error = (kp*p + ki*i + kd*d) / kscale;
tel

(* Computes weighted sum of sensor values *)
node weightedSum(sen_value, sen_weight, prev_sum: int) returns (weighted_sum: int)
let
    weighted_sum = prev_sum + sen_value * sen_weight;
tel

(* Computes weighted avg of sensor values *)
node senWeightedAvg(sen: int^5) returns (sensor_avg: int)
var aritmetic_sum: int;
let
    aritmetic_sum = fold<<5>>(+)(sen, 0) - sen[2];
    sensor_avg = if aritmetic_sum = 0 then 0 else fold<<5>>weightedSum(sen, sensor_weights, 0) / aritmetic_sum;
tel

(* node count_white(val, prev: int) returns (new: int)
let
    new = if val < 200 then prev+1 else prev;
tel
node white_or_black_map(sen0, sen1, sen2, sen3, sen4: int) returns (mapped_sen: int^5)
let
    raw_sen = [sen0, sen1, sen2, sen3, sen4];
    compliment_sen = [sensor_max - sen[0], sensor_max - sen[1], sensor_max - sen[2], sensor_max - sen[3], sensor_max - sen[4]];
    white_count = fold<<5>>(count_white)(raw_sen, 0);
    black_count = 5 - white_count;
    mapped_sen = if white_count >= black_count then raw_sen else compliment_sen;
tel *)

(*  esure motor speed stays in range [0,100] *)
const white_thresh: int = 300 -- sensor value less than white_thresh guarantees white
const black_thresh: int = 800 -- sensor value more than black_thresh guarantees black
node safe_motor_update(cur_speed, change: int) returns (new_speed: int)
let
    new_speed =     if (cur_speed + change) > 100 then 100
                    else if (cur_speed + change) < 0 then 0
                    else (cur_speed + change);
tel

node normalize_value(min_val, max_val, value: int) returns (norm_val: int)
var safe_val: int;
let
    safe_val = if value >= max_val then max_val else if value <= min_val then min_val else value;
    norm_val = ((safe_val - min_val)*1000)/(max_val - min_val)
tel 

node updateMins(cur_val, cur_min: int) returns(new_min: int)
let
    new_min = if (not(cur_val=0)) and (cur_val<cur_min) then cur_val else cur_min;
tel

node updateMaxs(cur_val, cur_max: int) returns(new_max: int)
let
    new_max = if cur_val > cur_max then cur_val else cur_max;
tel

node abs(input: int) returns(out: int)
let
    out = if input>=0 then input else -1*input;
tel


(* Main function for line following *)
node main(sen0, sen1, sen2, sen3, sen4: int) returns ( v_l, v_r, dir: int;)
var raw_sen, norm_sen, sen_white_line, sen_black_line: int^5; sensor_arithmetic_sum, sensor_avg: int; all_low, any_high, all_high, only_middle_high, only_middle_low: bool;
(* last : int = 1;  *)
last pid_error: int = 0;
last line_switched: bool = false;
last min_vals: int^5 = [420, 490, 430, 880, 340];
last max_vals: int^5 = [800, 860, 820, 950, 690];
last sen: int^5 = [0, 0, 0, 0, 0];
let
    raw_sen = [sen0, sen1, sen2, sen3, sen4];
    min_vals = (last min_vals); --  map<<5>>updateMins(raw_sen, (last min_vals));
    max_vals = map<<5>>updateMaxs(raw_sen, (last max_vals));
    norm_sen = map<<5>>normalize_value(min_vals, max_vals, raw_sen);
    sen_white_line = [norm_sen[0], norm_sen[1], norm_sen[2], norm_sen[3], norm_sen[4]];
    sen_black_line = [sensor_max - norm_sen[0], sensor_max - norm_sen[1], sensor_max - norm_sen[2], sensor_max - norm_sen[3], sensor_max - norm_sen[4]];
    sen = if (last line_switched) then sen_black_line else sen_white_line;
    (* processed_sen = sen; *)
    -- Compute error and PID error
    sensor_arithmetic_sum = fold<<5>>(+)(sen, 0);
    sensor_avg = senWeightedAvg(sen);
    pid_error = calPidError(sensor_avg);

    -- Determine robot movement direction
    all_low =  (sen[0]<=white_thresh and sen[1]<=white_thresh and sen[2]<=white_thresh and sen[3]<=white_thresh and sen[4]<=white_thresh);
    any_high =  (sen[0]>=black_thresh or sen[1]>=black_thresh or sen[2]>=black_thresh or sen[3]>=black_thresh or sen[4]>=black_thresh);
    only_middle_high =  (sen[0]<=white_thresh and sen[1]<=white_thresh and sen[2]>=black_thresh and sen[3]<=white_thresh and sen[4]<=white_thresh);
    only_middle_low =  (sen[0]>=black_thresh and sen[1]>=black_thresh and sen[2]<=white_thresh and sen[3]>=black_thresh and sen[4]>=black_thresh);

    all_high =  (sensor_arithmetic_sum > (black_thresh*5));
    automaton
        state Calibrate
            var ncycles: int;
            do v_l=base_sraight_speed; v_r=base_sraight_speed; dir=3;
                ncycles = 0->pre(ncycles) + 1;
            until ncycles>=50 and all_high then Idle
        state Idle
            do v_l=0; v_r=0; dir=0;
            unless all_high then Start
        state Start
            do v_l=base_sraight_speed; v_r=base_sraight_speed; dir=1;
            until not all_high then WonB
        state WonB
            do
                automaton
                    state PID
                        do 
                            automaton
                                state Straight
                                    (* var accl_cycles, accl: int; *)
                                    do
                                        (* accl_cycles = 0->if pre(accl_cycles) > 10 then 1 else pre(accl_cycles) + 1;
                                        accl = 0->if accl_cycles>=10 then pre(accl)+1 else pre(accl);
                                        v_l=base_sraight_speed+accl; v_r=base_sraight_speed+accl; dir=1; *)
                                        v_l=base_sraight_speed; v_r=base_sraight_speed; dir=1;
                                    unless abs(pid_error) >= 20 then SharpTurn
                                        | abs(pid_error) > 0 and abs(pid_error) < 20 then SoftTurn
                                state SoftTurn
                                    do
                                        v_l = safe_motor_update(base_turn_speed, pid_error);
                                        v_r = safe_motor_update(base_turn_speed, -1*pid_error);
                                        dir = 1;
                                    unless pid_error=0 then Straight
                                        |  abs(pid_error) >= 20 then SharpTurn
                                state SharpTurn
                                    do
                                        v_l = safe_motor_update(0, abs(pid_error));
                                        v_r = safe_motor_update(0, abs(pid_error));
                                        dir = if pid_error<0 then 2 else 3;
                                    unless pid_error=0 then Straight
                                        | abs(pid_error) > 0 and abs(pid_error) < 20 then SoftTurn
                            end
                        unless all_low then Recovery
                    state Recovery
                        do v_l=base_sraight_speed*3/4; v_r=base_sraight_speed*3/4; dir=4;
                        until not all_low then PID
                end
            until (all_high or only_middle_low) and (not line_switched) then Transition
        state Transition
            (* var numcycles: int; *)
            do
                (* -- go Straight for some time *)
                v_l=base_sraight_speed; v_r=base_sraight_speed*2; dir=20;
                line_switched = true;
            until not all_low continue BoW
         state BoW
            do
                automaton
                    state PID
                        do 
                            automaton
                                state Straight
                                    (* var accl_cycles, accl: int; *)
                                    do
                                        (* accl_cycles = 0->if pre(accl_cycles) > 10 then 1 else pre(accl_cycles) + 1;
                                        accl = 0->if accl_cycles>=10 then pre(accl)+1 else pre(accl);
                                        v_l=base_sraight_speed+accl; v_r=base_sraight_speed+accl; dir=1; *)
                                        v_l=base_sraight_speed; v_r=base_sraight_speed; dir=1;
                                    unless abs(pid_error) >= 20 then SharpTurn
                                        | abs(pid_error) > 0 and abs(pid_error) < 20 then SoftTurn
                                state SoftTurn
                                    do
                                        v_l = safe_motor_update(base_turn_speed, pid_error);
                                        v_r = safe_motor_update(base_turn_speed, -1*pid_error);
                                        dir = 1;
                                    unless pid_error=0 then Straight
                                        |  abs(pid_error) >= 20 then SharpTurn
                                state SharpTurn
                                    do
                                        v_l = safe_motor_update(0, abs(pid_error));
                                        v_r = safe_motor_update(0, abs(pid_error));
                                        dir = if pid_error<0 then 2 else 3;
                                    unless pid_error=0 then Straight
                                        | abs(pid_error) > 0 and abs(pid_error) < 20 then SoftTurn
                            end
                        unless all_low then Recovery
                            |  all_high then Intersection
                    state Intersection
                        var next_dir: int;
                        do
                            automaton
                                state GoStraight
                                    do
                                        v_l = base_turn_speed;
                                        v_r = base_turn_speed;
                                        dir = 1;
                                        next_dir = 0;
                                    until all_low then GoRight
                                        | only_middle_high then GoLeft
                                (* state GoLeftPrep
                                    do
                                        v_l = base_turn_speed;
                                        v_r = base_turn_speed;
                                        dir = 2;
                                        next_dir = 0;
                                    until all_low then GoLeft *)
                                state GoLeft
                                    do
                                        v_l = base_turn_speed;
                                        v_r = base_turn_speed;
                                        dir = 2;
                                        next_dir = if sen[1]>=black_thresh or sen[2]>=black_thresh then 2 else 0;
                                state GoRight
                                    do
                                        v_l = base_turn_speed;
                                        v_r = base_turn_speed;
                                        dir = 3;
                                        next_dir = if  sen[1]>=black_thresh or sen[2]>=black_thresh or sen[3]>=black_thresh then 1 else 0;
                            end
                        until not (next_dir=0) then PID
                    state Recovery
                        do v_l=base_sraight_speed*3/4; v_r=base_sraight_speed*3/4; dir=4;
                        until not all_low then PID
                    state Stop
                        do v_l=0; v_r=0; dir=0;
                end
        state ObsAvoid
            do v_l=0; v_r=0; dir=0;
        state Parking
            do v_l=0; v_r=0; dir=0;
    end
tel
